*阅读本文前请先阅读赛题说明（`/references/evenodd_spec.docx`）*。

## 规范
### 文件格式规范和处理规范
对于给定的文件，我们按每 $(p - 1)p$ 个 Bit 进行划分（不足补 0），分别进行 EVENODD 加密，然后将 $(p + 2)$ 列数据分别储存在文件夹 `disk0, disk1, ...` 里。

加密文件不拆分储存，文件名保持原文件名不变。

加密文件格式为 `<原文件字节数><p><二进制数据>`。三项均用二进制直接表示，`<原文件字节数>` 占 5 字节，`<p>` 占 1 字节。

二进制数据不足字节数则在末尾补 0（如 `011` 补至 `01100000`）。

例如，若原文件字节数为 $5 = (101)_2$，$p = 7 = (111)_2$，二进制数据为 `11001`，则加密文件内容为（在二进制下；为了阅读方便使用了换行和空格，实际文件中不存在）：

```plain
00000000 00000000 00000000 00000000   00000101 00000111 11001000
```

## 理论
### 加密
见 `/references/evenodd_spec.docx`。

### 解密
TODO

## 实现
### IO
读入使用 `Input_buffer`，输出使用 `Output_buffer`。

原理为缓存区 + `fread / fwrite`。

### uint128
为了提高计算效率，推荐使用 uint128 进行 bool 相关运算。

为了方便，推荐以列为第一编号存储数据，然后将行设为第二编号，用 `uint128 a[i]` 储存第 $i$ 列的信息。这样的好处是可以直接将 `a[i]` 读 / 写至第 $i + 1$ 个磁盘内。

### 加密实现
假设 $p = 4$，输入为 $\{x_0, x_1, \ldots, x_{11}\} \subseteq \{0, 1\}^{12}$，则

|       | disk0 | disk1 |  disk2   | disk 3 | disk 4 |
| :---: | :---: | :---: | :------: | :----: | :----: |
|   0   | $x_3$ | $x_7$ | $x_{11}$ |
|   1   | $x_2$ | $x_6$ | $x_{10}$ |
|   2   | $x_1$ | $x_5$ |  $x_9$   |
|   3   | $x_0$ | $x_4$ |  $x_8$   |

压缩到 `uint128` 为：

* $a_0 = (x_0x_1x_2x_3)_2$；
* $a_1 = (x_4x_5x_6x_7)_2$；
* $a_2 = (x_8x_9x_{10}x_{11})_2$。

可以注意到，disk 3 中 $a_3 = a_0 \oplus a_1 \oplus a_2$。

$a_4$ 的计算也很简单，此处不展开解释。

计算结束后，将 $a_i$ 直接输出到对应的磁盘。

**需要注意的是，尽管在转入表格时看起来改变了 $x$ 的顺序，但只需要正常计算 $a_i$ 的值并输出即可保证正确性，无需做特殊处理**。